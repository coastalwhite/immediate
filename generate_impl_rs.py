#! /usr/bin/env python3

STRUCT_BASE_NAME = "Bits"

# The comment that gets inserted at the beginning of each automatically
# generated file.
COMMENTS = """
//! This file is automatically generated with the `generate_impl_rs.py` script.
//! It basically just finds all the number combinations for which a certain
//! trait should be implemented.
""".strip()

# The imports that every automatically generated file does.
IMPORTS = """
use super::{Bits, BitsDownCast, BitsConcat};
""".strip()

def i_geq_j(_, i, j):
    return i >= j

def sum_of_sizes(size, i, j):
    if i < j:
        return None

    if i + j <= size:
        return i + j

    return None

trait_2arg_impls = {
    "Concat": sum_of_sizes,
}
trait_1arg_impls = {
    "DownCast": i_geq_j,
}

immediate_sizes = [
    32
    # 8, 16, 32, 64
]

def get_1arg_impl_string(name, size, x, y):
    return "impl {base}{size}{name}<{y}> for {base}{size}<{x}> {{}}".format(
        base=STRUCT_BASE_NAME,
        name=name,
        size='', 
        # size=size, 
        x=x, y=y,
    )

def get_2arg_impl_string(name, size, x, y, outcome):
    return "impl {base}{size}{name}<{y}, {outcome}> for {base}{size}<{x}> {{}}".format(
        base=STRUCT_BASE_NAME,
        name=name,
        size='', 
        # size=size, 
        x=x, y=y,
        outcome=outcome
    )

print(COMMENTS)
print("")
print(IMPORTS);
print("")
for size in immediate_sizes:
    # Loop over all combinations
    for i in range(1, size+1):
        for j in range(1, size+1):
            # 1 argument traits 
            for trait_name, trait_fn in trait_1arg_impls.items():
                if trait_fn(size, i, j):
                    print(get_1arg_impl_string(trait_name, size, i, j))

            # 2 argument traits
            for trait_name, trait_fn in trait_2arg_impls.items():
                outcome = trait_fn(size, i, j)

                if outcome != None:
                    print(get_2arg_impl_string(trait_name, size, i, j, outcome))